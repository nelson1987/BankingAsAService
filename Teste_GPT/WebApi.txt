
Aqui está um exemplo de como você poderia escrever uma classe em C# 7.0 que valida se todas as variáveis string de um código começam com "str" e impede que o projeto seja compilado se não estiverem escritas corretamente:


using System.Collections.Immutable;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Microsoft.CodeAnalysis.Diagnostics;

[DiagnosticAnalyzer(LanguageNames.CSharp)]
public class StringVariablePrefixAnalyzer : DiagnosticAnalyzer
{
    public const string DiagnosticId = "StringVariablePrefix";
    private static readonly LocalizableString Title = "String variable prefix";
    private static readonly LocalizableString MessageFormat = "All string variables must start with 'str'";
    private static readonly LocalizableString Description = "All string variables must start with 'str'";
    private const string Category = "Naming";

    private static DiagnosticDescriptor Rule = new DiagnosticDescriptor(DiagnosticId, Title, MessageFormat, Category, DiagnosticSeverity.Error, isEnabledByDefault: true, description: Description);

    public override ImmutableArray<DiagnosticDescriptor> SupportedDiagnostics { get { return ImmutableArray.Create(Rule); } }

    public override void Initialize(AnalysisContext context)
    {
        context.ConfigureGeneratedCodeAnalysis(GeneratedCodeAnalysisFlags.None);
        context.EnableConcurrentExecution();
        context.RegisterSyntaxNodeAction(AnalyzeVariableDeclaration, SyntaxKind.VariableDeclaration);
    }

    private void AnalyzeVariableDeclaration(SyntaxNodeAnalysisContext context)
    {
        var variableDeclaration = (VariableDeclarationSyntax)context.Node;
        if (variableDeclaration.Type.ToString() != "string")
        {
            return;
        }

        foreach (var variable in variableDeclaration.Variables)
        {
            if (!variable.Identifier.ValueText.StartsWith("str"))
            {
                var diagnostic = Diagnostic.Create(Rule, variable.GetLocation(), variable.Identifier.ValueText);
                context.ReportDiagnostic(diagnostic);
            }
        }
    }
}
Essa classe usa o Microsoft.CodeAnalysis para analisar o código e verificar se todas as variáveis do tipo string começam com "str". Se uma variável não estiver escrita corretamente, ela adiciona um diagnostic apropriado à lista de erros do Visual Studio com a mensagem "Todas as variáveis do tipo string, devem iniciar com str" e impede que o projeto seja compilado.

É importante notar que essa classe deve ser registrada e habilitada no seu projeto, caso contrário ela não irá funcionar.





Para referenciar um projeto de análise de código no projeto que será analisado, você precisará seguir os seguintes passos:

Certifique-se de que o projeto de análise de código esteja incluído na sua solução e que ele já tenha sido compilado.

Abra o projeto que você deseja analisar e adicione uma referência ao projeto de análise de código. Isso pode ser feito clicando com o botão direito do mouse no projeto de destino e selecionando "Adicionar > Referência...". Em seguida, selecione o projeto de análise de código na lista de projetos disponíveis e clique em "OK".

Abra o arquivo de código fonte onde você deseja habilitar a análise de código e adicione a seguinte linha de código no topo do arquivo:


#pragma warning disable <ID_do_aviso>
Para habilitar a análise de código, você precisará adicionar a seguinte linha no arquivo csproj do projeto de destino:

<PropertyGroup>
    <CodeAnalysisRuleSet>path/to/ruleset.ruleset</CodeAnalysisRuleSet>
</PropertyGroup>
Agora, quando você compilar o projeto de destino, o projeto de análise de código será executado e qualquer aviso ou erro será exibido na lista de erros do Visual Studio.
Obs: é importante notar que essa configuração pode variar de acordo com o ambiente de desenvolvimento utilizado, caso seja necessário mais detalhes, consulte a documentação do seu ambiente.





Existem vários tipos de testes que podem ser feitos em uma aplicação C# 7.0 usando o XUnit, aqui estão alguns exemplos:

Testes unitários: Testes que validam o comportamento de uma classe ou método específico sem depender de outras partes da aplicação.

Testes de integração: Testes que validam a comunicação entre diferentes partes da aplicação, como a comunicação entre diferentes módulos ou entre a aplicação e bancos de dados ou APIs externas.

Testes de aceitação: Testes que validam se a aplicação atende às necessidades funcionais especificadas pelo cliente ou usuário.

Testes de carga: Testes que medem o desempenho da aplicação sob uma carga específica, como a capacidade de lidar com grandes volumes de dados ou com um grande número de usuários simultâneos.

Testes de regressão: Testes que validam se uma alteração em uma parte da aplicação não afeta o comportamento de outras partes da aplicação.

Testes de segurança: Testes que validam se a aplicação está protegida contra ataques comuns, como SQL Injection ou Cross-site scripting (XSS).

Testes de consistência: Testes que validam se os dados gerados pela aplicação estão consistentes e precisos.

Testes de manutenção: Testes que validam se a aplicação é fácil de manter e se sua estrutura é clara e fácil de entender.

Todos esses tipos de testes podem ser feitos usando o XUnit, e ele fornece as ferramentas necessárias para criar e executar esses testes de forma eficiente e organizada.




É importante notar que esses são apenas exemplos simples e que você pode adaptá-los de acordo com suas necessidades específicas. Alguns exemplos pode precisar de mais configuração e outros pode precisar de mais códigos para validar o teste. Além disso, é importante lembrar que é essencial ter uma boa cobertura de testes e escrever testes que realmente verificam o comportamento desejado da aplicação.




Aqui está um exemplo de como criar um teste usando Moq, XUnit e o padrão CQRS para o método "Buscar" de uma entidade chamada "Aluno":

Neste exemplo, estamos usando Moq para criar um mock do repositório de Aluno e do Mediator, e configurando-os para retornar um aluno esperado quando o método "Buscar" é chamado. Em seguida, estamos testando se o aluno retornado pelo mediator é igual ao aluno esperado. No final, verificamos se o método "Buscar" foi chamado uma vez no repositório mockado.

É importante notar que essa é uma estrutura básica de teste, e pode ser necessário adicionar mais configurações ou verificações de acordo com a complexidade do seu código e das necessidades do seu projeto.
