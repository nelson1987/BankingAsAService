public class BasketballPlayer
{
    public string Name { get; set; }
    public int PointsScored { get; set; }
    public int Rebounds { get; set; }
    public int Assists { get; set; }

    public void ScorePoints()
    {
        //code to score points
    }

    public void GetRebounds()
    {
        //code to get rebounds
    }

    public void MakeAssists()
    {
        //code to make assists
    }
}
Cada jogador tem uma única responsabilidade, pontuar, pegar rebotes e fazer assistências.

Princípio Aberto-Fechado:
Copy code
public interface Shape
{
    double Area();
}

public class Square : Shape
{
    private double side;

    public Square(double side)
    {
        this.side = side;
    }

    public double Area()
    {
        return side * side;
    }
}

public class Circle : Shape
{
    private double radius;

    public Circle(double radius)
    {
        this.radius = radius;
    }

    public double Area()
    {
        return Math.PI * Math.Pow(radius, 2);
    }
}
As formas são abertas para extensão, mas fechadas para modificação, permitindo que sejam adicionadas novas formas sem precisar mudar o código existente.

Princípio de Substituição de Liskov:
Copy code
public class Rectangle
{
    public virtual int Width { get; set; }
    public virtual int Height { get; set; }

    public int Area()
    {
        return Width * Height;
    }
}

public class Square : Rectangle
{
    public override int Width
    {
        set { base.Width = base.Height = value; }
    }

    public override int Height
    {
        set { base.Width = base.Height = value; }
    }
}
A classe Quadrado pode substituir a classe Retângulo sem causar problemas.

Princípio da Segregação de Interface:
Copy code
public interface ICar
{
    void Drive();
    void Honk();
}

public interface ISportsCar : ICar
{
    void Drift();
}

public class SportsCar : ISportsCar
{
    public void Drive() { /* code to drive */ }
    public void Honk() { /* code to honk */ }
    public void Drift() { /* code to drift */ }
}
A classe SportsCar só usa as informações que precisa para implementar suas funcionalidades.

Princípio da Inversão de Dependência:
Copy code
public interface I



Nelson Neto
Concluir resposta 
Game
{
void Play();
}

public class BasketballGame : IGame
{
private IPlayer player;

Copy code
public BasketballGame(IPlayer player)
{
    this.player = player;
}

public void Play()
{
    player.ScorePoints();
    player.GetRebounds();
    player.MakeAssists();
}
}

Copy code
Neste exemplo, a classe BasketballGame não depende de uma classe específica de jogador, mas sim de uma interface IPlayer, o que permite que diferentes jogadores possam ser usados no jogo sem afetar o código existente.
